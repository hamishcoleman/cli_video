#!/usr/bin/env python3
#
# Wrapper around the youtube-dl library interface to try and make a usable
# CLI viewer with local cache
#

from __future__ import unicode_literals

import datetime
import json
import os
import socket
import subprocess
import sys
import urllib.request

# Define where the look for the youtube-dl libraries.  I would have used
# site.addsitedir(), but it does an append, not an insert...
sys.path.insert(0, os.path.expanduser('~/r/upstream/youtube-dl'))

import youtube_dl # noqa


def make_basename(info):
    """Given the json info, construct the output base filename"""

    bad = ' /[]*%"\':'
    bar = '_' * len(bad)
    trans = str.maketrans(bad, bar)

    title = info['title'].strip().translate(trans)
    id = info['id']

    title = title[:230-len(id)]
    return '-'.join([title, id])


def get_subs_url(info):
    """Given the json info, find the best url"""

    if 'requested_subtitles' not in info:
        return None

    if info['requested_subtitles'] is None:
        return None

    for subdef in info['requested_subtitles'].values():
        if subdef['ext'] == 'vtt':
            return subdef['url']

    return None


def get_subs(info):
    """Download the subtitles and return the string"""
    # TODO: returning the entire text could be a memory hog

    url = get_subs_url(info)
    if url is None:
        return None

    with urllib.request.urlopen(url) as response:
        subs = response.read()

    return subs


progress_data = {}


def progress_hook(d):
    if 'downloaded_bytes' in d:
        downloaded_bytes = d['downloaded_bytes']
    elif 'total_bytes_estimate' in d:
        downloaded_bytes = d['total_bytes_estimate']
    else:
        downloaded_bytes = 1

    seconds_downloaded = downloaded_bytes / progress_data['bps']

    triggered = False
    if not progress_data['triggered']:
        # TODO:
        # - the two thresholds should be parameterised
        if seconds_downloaded > 20:
            triggered = True
        elif downloaded_bytes > 3000000:
            triggered = True
        elif d['status'] == 'finished':
            triggered = True

    if triggered:
        progress_data['triggered'] = True

        # Could attempt to reduce the race condition, but not close it, by
        # sending the filename back up to the main process

        # if 'tmpfilename' in d:
        #     filename = d['tmpfilename']
        # else:
        #     filename = d['filename']

        progress_data['w'].write(b'a')


def print_info(url, rootname):
    print("url=", url)
    print("file=", rootname)


def main():
    # TODO:
    # - argsparser
    # - older subprocess does not have "run" method

    if len(sys.argv) < 2:
        r = subprocess.run(['xclip', '-o'], capture_output=True, text=True)
        url = r.stdout
    else:
        url = sys.argv[1]
    url = url.strip(' ')
    format = '43/18/35/45/22/best'
    cachedir = os.path.expanduser('~/.youtube')
    logdir = os.path.expanduser('~/s/organizer/youtube/')

    # FIXME:
    # if not url:
    #   url=`xclip -o`

    if not os.path.exists(cachedir):
        os.makedirs(cachedir)

    if not os.path.exists(logdir):
        os.makedirs(logdir)

    logfile = os.path.join(logdir, 'youtube.log.' + socket.gethostname())

    ydl_opts = {
        'quiet': True,
        'writesubtitles': True,  # causes extrac_info to fetch subtitle info
        'subtitleslangs': ['en', 'en-GB', 'en-US', 'en-AU', 'en-NZ', 'en-GB'],
        'format': format,
        'youtube_include_dash_manifest': False,
        'consoletitle': True,
        'progress_hooks': [progress_hook],
    }

    ydl = youtube_dl.YoutubeDL(ydl_opts)

    # Sometimes, format is not available (raises DownloadError)
    # TODO: handle this?  optional different formats? etc?

    # TODO:
    # - retry sometimes works
    # - distingush different errors

    # TODO:
    # - dont download the subtitles until we know it is not a playlist

    try:
        info = ydl.extract_info(url, download=False)
    except youtube_dl.DownloadError as e:
        print("DownloadError caught")
        exit(1)

    basename = make_basename(info)
    rootname = os.path.join(cachedir, basename)
    ext = info.get('ext', 'unknown')

    with open(rootname+'.info.json', 'w') as f:
        json.dump(info, f, indent=2, sort_keys=True, separators=(',', ': '))

    _type = info.get('_type')
    if _type == 'playlist':
        print("Playlist:", info.get('title',''))
        for entry in info.get('entries'):
            print(entry.get('webpage_url'))
            print("   ", entry.get('title'))
        exit(1)

    subsname = rootname+'.vtt'
    subs = get_subs(info)
    if subs is not None:
        with open(subsname, 'wb') as f:
            f.write(subs)

    filesize = info.get('filesize', 2000000)
    duration = info.get('duration', 60)

    if duration == 0:
        duration = 60

    progress_data['bps'] = filesize / duration
    progress_data['triggered'] = False

    print_info(url, rootname)

    now = datetime.datetime.now(datetime.timezone.utc).astimezone()
    now = now.replace(microsecond=0)
    nowstr = now.isoformat()
    with open(logfile, 'a') as f:
        f.write("{} {} {}.{}\n".format(nowstr, url, basename, ext))

    outname = rootname + '.' + ext
    ydl.params.update({
        'outtmpl': outname,
        'writesubtitles': False,  # we wrote them out above
    })

    # TODO:
    # - if file exists, perhaps we already have it downloaded ...
    # - if file.part exists, we are already downloading it ...

    r, w = os.pipe()
    r = os.fdopen(r, 'rb', 0)
    w = os.fdopen(w, 'wb', 0)

    pid = os.fork()
    if pid == 0:
        # child
        r.close()
        progress_data['w'] = w
        try:
            ydl.process_info(info)
        except AssertionError as e:
            # tell parent to quit
            progress_data['w'].write(b'e')
            raise(e)

        exit(0)

    # parent
    w.close()

    # Wait on trigger byte
    c = r.read(1).decode('utf-8')
    if c is None:
        print("Got EOF on pipe")

    if c == 'e':
        print("Child sent us an error indicator")
        exit(1)

    if c != 'a':
        print("Child sent Unexpected '" + c + "' on pipe")

    if 'DISPLAY' in os.environ:
        # If we have no display, dont try to play it

        if os.path.exists(outname):
            filename = outname
        else:
            # FIXME - race condition with file completing..
            filename = outname + '.part'

        args = ['mplayer']
        args += ['-stop-xscreensaver']

        if subs is not None:
            args += ['-sub', subsname]
        args += [filename]

        r = subprocess.run(
            args,
            stdin=0,
            stdout=1,
            stderr=2,
        )
        print_info(url, rootname)
        returncode = r.returncode
    else:
        returncode = 0

    exit(returncode)

    # FIXME:
    # - if download has not finished, we hang here, waiting


if __name__ == '__main__':
    main()
